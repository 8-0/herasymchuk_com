{"version":3,"sources":["webpack:///./node_modules/@formatjs/intl-pluralrules/dist/locale-data sync en|ru|uk","webpack:///./.cache/emitter.js","webpack:///./.cache/react-lifecycles-compat.js","webpack:///./src/components/App/App.tsx","webpack:///./gatsby-browser.js","webpack:///./.cache/page-renderer.js","webpack:///./.cache/api-runner-browser-plugins.js","webpack:///./.cache/register-service-worker.js","webpack:///./node_modules/@formatjs/intl-relativetimeformat/dist/locale-data sync en|ru|uk","webpack:///./.cache/navigation.js","webpack:///./.cache/ensure-resources.js","webpack:///./.cache/production-app.js","webpack:///./.cache/gatsby-browser-entry.js","webpack:///./.cache/strip-prefix.js","webpack:///./.cache/prefetch.js","webpack:///./.cache/normalize-page-path.js","webpack:///./.cache/find-path.js","webpack:///./.cache/loader.js","webpack:///./.cache/public-page-renderer.js","webpack:///./.cache/create-react-context.js","webpack:///./.cache/async-requires.js","webpack:///./.cache/public-page-renderer-prod.js","webpack:///./src/theme.ts","webpack:///./.cache/api-runner-browser.js"],"names":["map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","module","exports","emitter","mitt","polyfill","Component","App","element","theme","wrapRootElement","props","PageRenderer","render","this","pathContext","pageContext","pageElement","apiRunner","loader","publicLoader","createElement","pageResources","component","key","path","page","result","pop","React","plugin","require","options","window","location","protocol","hostname","console","error","navigator","serviceWorker","register","then","reg","addEventListener","installingWorker","installing","log","state","controller","___swUpdated","___failedResources","reload","catch","redirectMap","redirects","reduce","redirect","fromPath","maybeRedirect","pathname","___replace","toPath","onPreRouteUpdate","prevLocation","onRouteUpdate","__navigatingToLink","navigate","to","replace","parsePath","timeoutId","setTimeout","emit","loadPage","status","history","replaceState","href","webpackCompilationHash","___webpackCompilationHash","postMessage","gatsbyApi","reachNavigate","clearTimeout","shouldUpdateScroll","prevRouterProps","hash","results","routerProps","getSavedScrollPosition","args","_stateStorage","read","length","decodeURI","slice","RouteAnnouncer","announcementRef","createRef","componentDidUpdate","prevProps","nextProps","requestAnimationFrame","pageName","document","title","pageHeadings","getElementById","getElementsByTagName","textContent","newAnnouncement","current","innerText","style","position","top","width","height","padding","overflow","clip","whiteSpace","border","aria-live","aria-atomic","ref","RouteUpdates","componentDidMount","prevState","shouldFireRouteUpdate","getSnapshotBeforeUpdate","Fragment","children","EnsureResources","loadPageSync","getDerivedStateFromProps","loadResources","rawPath","setState","shouldComponentUpdate","nextState","json","matchPath","shallowCompare","ProdLoader","asyncRequires","matchPaths","setLoader","setApiRunner","___emitter","___loader","___push","___navigate","apiRunnerAsync","RouteHandler","Provider","value","baseuri","basepath","LocationHandler","__BASE_PATH__","stripPrefix","encodeURI","pagePath","browserLoc","findMatchPath","match","search","Root","locationContext","WrappedRoot","NewRoot","renderer","undefined","ReactDOM","hydrate","domReady","prefetchPathname","enqueue","StaticQueryContext","createContext","StaticQueryDataRenderer","staticQueryData","data","query","finalData","StaticQuery","Consumer","useStaticQuery","useContext","context","graphql","str","prefix","substr","supportedPrefetchStrategy","feature","fakeLink","relList","supports","err","support","url","Promise","reject","link","setAttribute","forEach","onload","onerror","getElementsByName","parentNode","appendChild","XMLHttpRequest","open","send","preFetched","prefetch","charAt","pathCache","Map","trimPathname","rawPathname","decodeURIComponent","split","trimmedPathname","cleanPath","normalizePagePath","findPath","has","get","foundPath","set","instance","preferDefault","m","default","createPageDataUrl","s","endsWith","doFetch","method","onreadystatechange","readyState","loadPageDataJson","loadObj","retries","responseText","jsonPayload","JSON","parse","assign","payload","notFound","toPageResources","pageData","componentChunkName","BaseLoader","loadComponent","pageDb","inFlightDb","pageDataDb","prefetchTriggered","Set","prefetchCompleted","prefetchDisabled","some","a","inFlight","all","loadAppData","allData","finalResult","createdAt","Date","response","delete","shouldPrefetch","connection","effectiveType","includes","saveData","doesConnectionSupportPrefetch","add","realPath","doPrefetch","hovering","getResourceURLsForPathname","createComponentUrls","isPageNotFound","appData","___chunkMapping","chunk","__PATH_PREFIX__","chunkName","components","pageDataUrl","prefetchHelper","crossOrigin","as","componentUrls","_loader","getResourcesForPathname","warn","i","getResourcesForPathnameSync","ProdPageRenderer","InternalPageRenderer","color","primary","secondary","tertiary","gray","lightest","light","medium","dark","darkest","text","heading","body","disabled","spacing","unit","shape","borderRadius","small","large","plugins","api","defaultReturn","argTransform","filter","previous","next"],"mappings":"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","file":"app-1c684119e25438068578.js","sourcesContent":["var map = {\n\t\"./en\": \"Wud9\",\n\t\"./en.js\": \"Wud9\",\n\t\"./ru\": \"eQfh\",\n\t\"./ru.js\": \"eQfh\",\n\t\"./uk\": \"PYy7\",\n\t\"./uk.js\": \"PYy7\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"5NvR\";","import mitt from \"mitt\"\n\nconst emitter = mitt()\nexport default emitter\n","exports.polyfill = Component => Component\n","import React, { ReactNode } from 'react';\nimport { ThemeProvider } from 'emotion-theming';\n\nimport theme from '../../theme';\n\n/**\n * This component exists to provide a reusable application wrapper for use in Gatsby API's, testing, etc.\n */\nconst App = ({ element }: { element: ReactNode }) => {\n  return <ThemeProvider theme={theme}>{element}</ThemeProvider>;\n};\n\nexport default App;\n","import React from 'react';\n\nimport { App } from './src/components/App';\n\n// Duplicated in gatsby-ssr.js for server side rendering during the build\nexport const wrapRootElement = props => <App {...props} />;\n","import React, { createElement } from \"react\"\nimport PropTypes from \"prop-types\"\nimport { publicLoader } from \"./loader\"\nimport { apiRunner } from \"./api-runner-browser\"\n\n// Renders page\nclass PageRenderer extends React.Component {\n  render() {\n    const props = {\n      ...this.props,\n      pathContext: this.props.pageContext,\n    }\n\n    const [replacementElement] = apiRunner(`replaceComponentRenderer`, {\n      props: this.props,\n      loader: publicLoader,\n    })\n\n    const pageElement =\n      replacementElement ||\n      createElement(this.props.pageResources.component, {\n        ...props,\n        key: this.props.path || this.props.pageResources.page.path,\n      })\n\n    const wrappedPage = apiRunner(\n      `wrapPageElement`,\n      { element: pageElement, props },\n      pageElement,\n      ({ result }) => {\n        return { element: result, props }\n      }\n    ).pop()\n\n    return wrappedPage\n  }\n}\n\nPageRenderer.propTypes = {\n  location: PropTypes.object.isRequired,\n  pageResources: PropTypes.object.isRequired,\n  data: PropTypes.object,\n  pageContext: PropTypes.object.isRequired,\n}\n\nexport default PageRenderer\n","module.exports = [{\n      plugin: require('../node_modules/gatsby-plugin-intl/gatsby-browser.js'),\n      options: {\"plugins\":[],\"path\":\"/home/runner/work/herasymchuk_com/herasymchuk_com/src/locales\",\"languages\":[\"en\",\"ru\",\"uk\"],\"defaultLanguage\":\"uk\",\"redirect\":true},\n    },{\n      plugin: require('../gatsby-browser.js'),\n      options: {\"plugins\":[]},\n    }]\n","import { apiRunner } from \"./api-runner-browser\"\n\nif (\n  window.location.protocol !== `https:` &&\n  window.location.hostname !== `localhost`\n) {\n  console.error(\n    `Service workers can only be used over HTTPS, or on localhost for development`\n  )\n} else if (`serviceWorker` in navigator) {\n  navigator.serviceWorker\n    .register(`${__BASE_PATH__}/sw.js`)\n    .then(function(reg) {\n      reg.addEventListener(`updatefound`, () => {\n        apiRunner(`onServiceWorkerUpdateFound`, { serviceWorker: reg })\n        // The updatefound event implies that reg.installing is set; see\n        // https://w3c.github.io/ServiceWorker/#service-worker-registration-updatefound-event\n        const installingWorker = reg.installing\n        console.log(`installingWorker`, installingWorker)\n        installingWorker.addEventListener(`statechange`, () => {\n          switch (installingWorker.state) {\n            case `installed`:\n              if (navigator.serviceWorker.controller) {\n                // At this point, the old content will have been purged and the fresh content will\n                // have been added to the cache.\n\n                // We set a flag so Gatsby Link knows to refresh the page on next navigation attempt\n                window.___swUpdated = true\n                // We call the onServiceWorkerUpdateReady API so users can show update prompts.\n                apiRunner(`onServiceWorkerUpdateReady`, { serviceWorker: reg })\n\n                // If resources failed for the current page, reload.\n                if (window.___failedResources) {\n                  console.log(`resources failed, SW updated - reloading`)\n                  window.location.reload()\n                }\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a \"Content is cached for offline use.\" message.\n                console.log(`Content is now available offline!`)\n\n                // Post to service worker that install is complete.\n                // Delay to allow time for the event listener to be added --\n                // otherwise fetch is called too soon and resources aren't cached.\n                apiRunner(`onServiceWorkerInstalled`, { serviceWorker: reg })\n              }\n              break\n\n            case `redundant`:\n              console.error(`The installing service worker became redundant.`)\n              apiRunner(`onServiceWorkerRedundant`, { serviceWorker: reg })\n              break\n\n            case `activated`:\n              apiRunner(`onServiceWorkerActive`, { serviceWorker: reg })\n              break\n          }\n        })\n      })\n    })\n    .catch(function(e) {\n      console.error(`Error during service worker registration:`, e)\n    })\n}\n","var map = {\n\t\"./en\": \"Smhr\",\n\t\"./en.js\": \"Smhr\",\n\t\"./en.json\": \"a2ws\",\n\t\"./ru\": \"KZEZ\",\n\t\"./ru.js\": \"KZEZ\",\n\t\"./ru.json\": \"ifOQ\",\n\t\"./uk\": \"GTEr\",\n\t\"./uk.js\": \"GTEr\",\n\t\"./uk.json\": \"NXbT\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"PtxE\";","import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport loader from \"./loader\"\nimport redirects from \"./redirects.json\"\nimport { apiRunner } from \"./api-runner-browser\"\nimport emitter from \"./emitter\"\nimport { navigate as reachNavigate } from \"@reach/router\"\nimport { parsePath } from \"gatsby-link\"\n\n// Convert to a map for faster lookup in maybeRedirect()\nconst redirectMap = redirects.reduce((map, redirect) => {\n  map[redirect.fromPath] = redirect\n  return map\n}, {})\n\nfunction maybeRedirect(pathname) {\n  const redirect = redirectMap[pathname]\n\n  if (redirect != null) {\n    if (process.env.NODE_ENV !== `production`) {\n      const pageResources = loader.loadPageSync(pathname)\n\n      if (pageResources != null) {\n        console.error(\n          `The route \"${pathname}\" matches both a page and a redirect; this is probably not intentional.`\n        )\n      }\n    }\n\n    window.___replace(redirect.toPath)\n    return true\n  } else {\n    return false\n  }\n}\n\nconst onPreRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onPreRouteUpdate`, { location, prevLocation })\n  }\n}\n\nconst onRouteUpdate = (location, prevLocation) => {\n  if (!maybeRedirect(location.pathname)) {\n    apiRunner(`onRouteUpdate`, { location, prevLocation })\n    // Temp hack while awaiting https://github.com/reach/router/issues/119\n    window.__navigatingToLink = false\n  }\n}\n\nconst navigate = (to, options = {}) => {\n  // Temp hack while awaiting https://github.com/reach/router/issues/119\n  if (!options.replace) {\n    window.__navigatingToLink = true\n  }\n\n  let { pathname } = parsePath(to)\n  const redirect = redirectMap[pathname]\n\n  // If we're redirecting, just replace the passed in pathname\n  // to the one we want to redirect to.\n  if (redirect) {\n    to = redirect.toPath\n    pathname = parsePath(to).pathname\n  }\n\n  // If we had a service worker update, no matter the path, reload window and\n  // reset the pathname whitelist\n  if (window.___swUpdated) {\n    window.location = pathname\n    return\n  }\n\n  // Start a timer to wait for a second before transitioning and showing a\n  // loader in case resources aren't around yet.\n  const timeoutId = setTimeout(() => {\n    emitter.emit(`onDelayedLoadPageResources`, { pathname })\n    apiRunner(`onRouteUpdateDelayed`, {\n      location: window.location,\n    })\n  }, 1000)\n\n  loader.loadPage(pathname).then(pageResources => {\n    // If no page resources, then refresh the page\n    // Do this, rather than simply `window.location.reload()`, so that\n    // pressing the back/forward buttons work - otherwise when pressing\n    // back, the browser will just change the URL and expect JS to handle\n    // the change, which won't always work since it might not be a Gatsby\n    // page.\n    if (!pageResources || pageResources.status === `error`) {\n      window.history.replaceState({}, ``, location.href)\n      window.location = pathname\n    }\n    // If the loaded page has a different compilation hash to the\n    // window, then a rebuild has occurred on the server. Reload.\n    if (process.env.NODE_ENV === `production` && pageResources) {\n      if (\n        pageResources.page.webpackCompilationHash !==\n        window.___webpackCompilationHash\n      ) {\n        // Purge plugin-offline cache\n        if (\n          `serviceWorker` in navigator &&\n          navigator.serviceWorker.controller !== null &&\n          navigator.serviceWorker.controller.state === `activated`\n        ) {\n          navigator.serviceWorker.controller.postMessage({\n            gatsbyApi: `clearPathResources`,\n          })\n        }\n\n        console.log(`Site has changed on server. Reloading browser`)\n        window.location = pathname\n      }\n    }\n    reachNavigate(to, options)\n    clearTimeout(timeoutId)\n  })\n}\n\nfunction shouldUpdateScroll(prevRouterProps, { location }) {\n  const { pathname, hash } = location\n  const results = apiRunner(`shouldUpdateScroll`, {\n    prevRouterProps,\n    // `pathname` for backwards compatibility\n    pathname,\n    routerProps: { location },\n    getSavedScrollPosition: args => this._stateStorage.read(args),\n  })\n  if (results.length > 0) {\n    // Use the latest registered shouldUpdateScroll result, this allows users to override plugin's configuration\n    // @see https://github.com/gatsbyjs/gatsby/issues/12038\n    return results[results.length - 1]\n  }\n\n  if (prevRouterProps) {\n    const {\n      location: { pathname: oldPathname },\n    } = prevRouterProps\n    if (oldPathname === pathname) {\n      // Scroll to element if it exists, if it doesn't, or no hash is provided,\n      // scroll to top.\n      return hash ? decodeURI(hash.slice(1)) : [0, 0]\n    }\n  }\n  return true\n}\n\nfunction init() {\n  // Temp hack while awaiting https://github.com/reach/router/issues/119\n  window.__navigatingToLink = false\n\n  window.___push = to => navigate(to, { replace: false })\n  window.___replace = to => navigate(to, { replace: true })\n  window.___navigate = (to, options) => navigate(to, options)\n\n  // Check for initial page-load redirect\n  maybeRedirect(window.location.pathname)\n}\n\nclass RouteAnnouncer extends React.Component {\n  constructor(props) {\n    super(props)\n    this.announcementRef = React.createRef()\n  }\n\n  componentDidUpdate(prevProps, nextProps) {\n    requestAnimationFrame(() => {\n      let pageName = `new page at ${this.props.location.pathname}`\n      if (document.title) {\n        pageName = document.title\n      }\n      const pageHeadings = document\n        .getElementById(`gatsby-focus-wrapper`)\n        .getElementsByTagName(`h1`)\n      if (pageHeadings && pageHeadings.length) {\n        pageName = pageHeadings[0].textContent\n      }\n      const newAnnouncement = `Navigated to ${pageName}`\n      const oldAnnouncement = this.announcementRef.current.innerText\n      if (oldAnnouncement !== newAnnouncement) {\n        this.announcementRef.current.innerText = newAnnouncement\n      }\n    })\n  }\n\n  render() {\n    return (\n      <div\n        id=\"gatsby-announcer\"\n        style={{\n          position: `absolute`,\n          top: 0,\n          width: 1,\n          height: 1,\n          padding: 0,\n          overflow: `hidden`,\n          clip: `rect(0, 0, 0, 0)`,\n          whiteSpace: `nowrap`,\n          border: 0,\n        }}\n        aria-live=\"assertive\"\n        aria-atomic=\"true\"\n        ref={this.announcementRef}\n      ></div>\n    )\n  }\n}\n\n// Fire on(Pre)RouteUpdate APIs\nclass RouteUpdates extends React.Component {\n  constructor(props) {\n    super(props)\n    onPreRouteUpdate(props.location, null)\n  }\n\n  componentDidMount() {\n    onRouteUpdate(this.props.location, null)\n  }\n\n  componentDidUpdate(prevProps, prevState, shouldFireRouteUpdate) {\n    if (shouldFireRouteUpdate) {\n      onRouteUpdate(this.props.location, prevProps.location)\n    }\n  }\n\n  getSnapshotBeforeUpdate(prevProps) {\n    if (this.props.location.pathname !== prevProps.location.pathname) {\n      onPreRouteUpdate(this.props.location, prevProps.location)\n      return true\n    }\n\n    return false\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        {this.props.children}\n        <RouteAnnouncer location={location} />\n      </React.Fragment>\n    )\n  }\n}\n\nRouteUpdates.propTypes = {\n  location: PropTypes.object.isRequired,\n}\n\nexport { init, shouldUpdateScroll, RouteUpdates }\n","import React from \"react\"\nimport loader from \"./loader\"\nimport shallowCompare from \"shallow-compare\"\n\nclass EnsureResources extends React.Component {\n  constructor(props) {\n    super()\n    const { location, pageResources } = props\n    this.state = {\n      location: { ...location },\n      pageResources: pageResources || loader.loadPageSync(location.pathname),\n    }\n  }\n\n  static getDerivedStateFromProps({ location }, prevState) {\n    if (prevState.location.href !== location.href) {\n      const pageResources = loader.loadPageSync(location.pathname)\n      return {\n        pageResources,\n        location: { ...location },\n      }\n    }\n\n    return {\n      location: { ...location },\n    }\n  }\n\n  loadResources(rawPath) {\n    loader.loadPage(rawPath).then(pageResources => {\n      if (pageResources && pageResources.status !== `error`) {\n        this.setState({\n          location: { ...window.location },\n          pageResources,\n        })\n      } else {\n        window.history.replaceState({}, ``, location.href)\n        window.location = rawPath\n      }\n    })\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // Always return false if we're missing resources.\n    if (!nextState.pageResources) {\n      this.loadResources(nextProps.location.pathname)\n      return false\n    }\n\n    // Check if the component or json have changed.\n    if (this.state.pageResources !== nextState.pageResources) {\n      return true\n    }\n    if (\n      this.state.pageResources.component !== nextState.pageResources.component\n    ) {\n      return true\n    }\n\n    if (this.state.pageResources.json !== nextState.pageResources.json) {\n      return true\n    }\n    // Check if location has changed on a page using internal routing\n    // via matchPath configuration.\n    if (\n      this.state.location.key !== nextState.location.key &&\n      nextState.pageResources.page &&\n      (nextState.pageResources.page.matchPath ||\n        nextState.pageResources.page.path)\n    ) {\n      return true\n    }\n    return shallowCompare(this, nextProps, nextState)\n  }\n\n  render() {\n    return this.props.children(this.state)\n  }\n}\n\nexport default EnsureResources\n","import { apiRunner, apiRunnerAsync } from \"./api-runner-browser\"\nimport React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { Router, navigate, Location, BaseContext } from \"@reach/router\"\nimport { ScrollContext } from \"gatsby-react-router-scroll\"\nimport domReady from \"@mikaelkristiansson/domready\"\nimport {\n  shouldUpdateScroll,\n  init as navigationInit,\n  RouteUpdates,\n} from \"./navigation\"\nimport emitter from \"./emitter\"\nimport PageRenderer from \"./page-renderer\"\nimport asyncRequires from \"./async-requires\"\nimport { setLoader, ProdLoader, publicLoader } from \"./loader\"\nimport EnsureResources from \"./ensure-resources\"\nimport stripPrefix from \"./strip-prefix\"\n\n// Generated during bootstrap\nimport matchPaths from \"./match-paths.json\"\n\nconst loader = new ProdLoader(asyncRequires, matchPaths)\nsetLoader(loader)\nloader.setApiRunner(apiRunner)\n\nwindow.asyncRequires = asyncRequires\nwindow.___emitter = emitter\nwindow.___loader = publicLoader\n\nnavigationInit()\n\napiRunnerAsync(`onClientEntry`).then(() => {\n  // Let plugins register a service worker. The plugin just needs\n  // to return true.\n  if (apiRunner(`registerServiceWorker`).length > 0) {\n    require(`./register-service-worker`)\n  }\n\n  // In gatsby v2 if Router is used in page using matchPaths\n  // paths need to contain full path.\n  // For example:\n  //   - page have `/app/*` matchPath\n  //   - inside template user needs to use `/app/xyz` as path\n  // Resetting `basepath`/`baseuri` keeps current behaviour\n  // to not introduce breaking change.\n  // Remove this in v3\n  const RouteHandler = props => (\n    <BaseContext.Provider\n      value={{\n        baseuri: `/`,\n        basepath: `/`,\n      }}\n    >\n      <PageRenderer {...props} />\n    </BaseContext.Provider>\n  )\n\n  class LocationHandler extends React.Component {\n    render() {\n      const { location } = this.props\n      return (\n        <EnsureResources location={location}>\n          {({ pageResources, location }) => (\n            <RouteUpdates location={location}>\n              <ScrollContext\n                location={location}\n                shouldUpdateScroll={shouldUpdateScroll}\n              >\n                <Router\n                  basepath={__BASE_PATH__}\n                  location={location}\n                  id=\"gatsby-focus-wrapper\"\n                >\n                  <RouteHandler\n                    path={\n                      pageResources.page.path === `/404.html`\n                        ? stripPrefix(location.pathname, __BASE_PATH__)\n                        : encodeURI(\n                            pageResources.page.matchPath ||\n                              pageResources.page.path\n                          )\n                    }\n                    {...this.props}\n                    location={location}\n                    pageResources={pageResources}\n                    {...pageResources.json}\n                  />\n                </Router>\n              </ScrollContext>\n            </RouteUpdates>\n          )}\n        </EnsureResources>\n      )\n    }\n  }\n\n  const { pagePath, location: browserLoc } = window\n\n  // Explicitly call navigate if the canonical path (window.pagePath)\n  // is different to the browser path (window.location.pathname). But\n  // only if NONE of the following conditions hold:\n  //\n  // - The url matches a client side route (page.matchPath)\n  // - it's a 404 page\n  // - it's the offline plugin shell (/offline-plugin-app-shell-fallback/)\n  if (\n    pagePath &&\n    __BASE_PATH__ + pagePath !== browserLoc.pathname &&\n    !(\n      loader.findMatchPath(stripPrefix(browserLoc.pathname, __BASE_PATH__)) ||\n      pagePath === `/404.html` ||\n      pagePath.match(/^\\/404\\/?$/) ||\n      pagePath.match(/^\\/offline-plugin-app-shell-fallback\\/?$/)\n    )\n  ) {\n    navigate(__BASE_PATH__ + pagePath + browserLoc.search + browserLoc.hash, {\n      replace: true,\n    })\n  }\n\n  publicLoader.loadPage(browserLoc.pathname).then(page => {\n    if (!page || page.status === `error`) {\n      throw new Error(\n        `page resources for ${browserLoc.pathname} not found. Not rendering React`\n      )\n    }\n\n    window.___webpackCompilationHash = page.page.webpackCompilationHash\n\n    const Root = () => (\n      <Location>\n        {locationContext => <LocationHandler {...locationContext} />}\n      </Location>\n    )\n\n    const WrappedRoot = apiRunner(\n      `wrapRootElement`,\n      { element: <Root /> },\n      <Root />,\n      ({ result }) => {\n        return { element: result }\n      }\n    ).pop()\n\n    const NewRoot = () => WrappedRoot\n\n    const renderer = apiRunner(\n      `replaceHydrateFunction`,\n      undefined,\n      ReactDOM.hydrate\n    )[0]\n\n    domReady(() => {\n      renderer(\n        <NewRoot />,\n        typeof window !== `undefined`\n          ? document.getElementById(`___gatsby`)\n          : void 0,\n        () => {\n          apiRunner(`onInitialClientRender`)\n        }\n      )\n    })\n  })\n})\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport Link, {\n  withPrefix,\n  withAssetPrefix,\n  navigate,\n  push,\n  replace,\n  navigateTo,\n  parsePath,\n} from \"gatsby-link\"\nimport PageRenderer from \"./public-page-renderer\"\nimport loader from \"./loader\"\n\nconst prefetchPathname = loader.enqueue\n\nconst StaticQueryContext = React.createContext({})\n\nfunction StaticQueryDataRenderer({ staticQueryData, data, query, render }) {\n  const finalData = data\n    ? data.data\n    : staticQueryData[query] && staticQueryData[query].data\n\n  return (\n    <React.Fragment>\n      {finalData && render(finalData)}\n      {!finalData && <div>Loading (StaticQuery)</div>}\n    </React.Fragment>\n  )\n}\n\nconst StaticQuery = props => {\n  const { data, query, render, children } = props\n\n  return (\n    <StaticQueryContext.Consumer>\n      {staticQueryData => (\n        <StaticQueryDataRenderer\n          data={data}\n          query={query}\n          render={render || children}\n          staticQueryData={staticQueryData}\n        />\n      )}\n    </StaticQueryContext.Consumer>\n  )\n}\n\nconst useStaticQuery = query => {\n  if (\n    typeof React.useContext !== `function` &&\n    process.env.NODE_ENV === `development`\n  ) {\n    throw new Error(\n      `You're likely using a version of React that doesn't support Hooks\\n` +\n        `Please update React and ReactDOM to 16.8.0 or later to use the useStaticQuery hook.`\n    )\n  }\n  const context = React.useContext(StaticQueryContext)\n  if (context[query] && context[query].data) {\n    return context[query].data\n  } else {\n    throw new Error(\n      `The result of this StaticQuery could not be fetched.\\n\\n` +\n        `This is likely a bug in Gatsby and if refreshing the page does not fix it, ` +\n        `please open an issue in https://github.com/gatsbyjs/gatsby/issues`\n    )\n  }\n}\n\nStaticQuery.propTypes = {\n  data: PropTypes.object,\n  query: PropTypes.string.isRequired,\n  render: PropTypes.func,\n  children: PropTypes.func,\n}\n\nfunction graphql() {\n  throw new Error(\n    `It appears like Gatsby is misconfigured. Gatsby related \\`graphql\\` calls ` +\n      `are supposed to only be evaluated at compile time, and then compiled away. ` +\n      `Unfortunately, something went wrong and the query was left in the compiled code.\\n\\n` +\n      `Unless your site has a complex or custom babel/Gatsby configuration this is likely a bug in Gatsby.`\n  )\n}\n\nexport {\n  Link,\n  withAssetPrefix,\n  withPrefix,\n  graphql,\n  parsePath,\n  navigate,\n  push, // TODO replace for v3\n  replace, // TODO remove replace for v3\n  navigateTo, // TODO: remove navigateTo for v3\n  StaticQueryContext,\n  StaticQuery,\n  PageRenderer,\n  useStaticQuery,\n  prefetchPathname,\n}\n","/**\n * Remove a prefix from a string. Return the input string if the given prefix\n * isn't found.\n */\n\nexport default (str, prefix = ``) => {\n  if (!prefix) {\n    return str\n  }\n\n  prefix += `/`\n\n  if (str.substr(0, prefix.length) === prefix) {\n    return str.slice(prefix.length - 1)\n  }\n\n  return str\n}\n","const support = function(feature) {\n  if (typeof document === `undefined`) {\n    return false\n  }\n  const fakeLink = document.createElement(`link`)\n  try {\n    if (fakeLink.relList && typeof fakeLink.relList.supports === `function`) {\n      return fakeLink.relList.supports(feature)\n    }\n  } catch (err) {\n    return false\n  }\n  return false\n}\n\nconst linkPrefetchStrategy = function(url, options) {\n  return new Promise((resolve, reject) => {\n    if (typeof document === `undefined`) {\n      reject()\n      return\n    }\n\n    const link = document.createElement(`link`)\n    link.setAttribute(`rel`, `prefetch`)\n    link.setAttribute(`href`, url)\n\n    Object.keys(options).forEach(key => {\n      link.setAttribute(key, options[key])\n    })\n\n    link.onload = resolve\n    link.onerror = reject\n\n    const parentElement =\n      document.getElementsByTagName(`head`)[0] ||\n      document.getElementsByName(`script`)[0].parentNode\n    parentElement.appendChild(link)\n  })\n}\n\nconst xhrPrefetchStrategy = function(url) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n    req.open(`GET`, url, true)\n\n    req.onload = () => {\n      if (req.status === 200) {\n        resolve()\n      } else {\n        reject()\n      }\n    }\n\n    req.send(null)\n  })\n}\n\nconst supportedPrefetchStrategy = support(`prefetch`)\n  ? linkPrefetchStrategy\n  : xhrPrefetchStrategy\n\nconst preFetched = {}\n\nconst prefetch = function(url, options) {\n  return new Promise(resolve => {\n    if (preFetched[url]) {\n      resolve()\n      return\n    }\n\n    supportedPrefetchStrategy(url, options)\n      .then(() => {\n        resolve()\n        preFetched[url] = true\n      })\n      .catch(() => {}) // 404s are logged to the console anyway\n  })\n}\n\nexport default prefetch\n","export default path => {\n  if (path === undefined) {\n    return path\n  }\n  if (path === `/`) {\n    return `/`\n  }\n  if (path.charAt(path.length - 1) === `/`) {\n    return path.slice(0, -1)\n  }\n  return path\n}\n","import { match } from \"@reach/router/lib/utils\"\nimport stripPrefix from \"./strip-prefix\"\nimport normalizePagePath from \"./normalize-page-path\"\n\nconst pathCache = new Map()\nlet matchPaths = []\n\nconst trimPathname = rawPathname => {\n  const pathname = decodeURIComponent(rawPathname)\n  // Remove the pathPrefix from the pathname.\n  const trimmedPathname = stripPrefix(pathname, __BASE_PATH__)\n    // Remove any hashfragment\n    .split(`#`)[0]\n    // Remove search query\n    .split(`?`)[0]\n\n  return trimmedPathname\n}\n\n/**\n * Set list of matchPaths\n *\n * @param {Array<{path: string, matchPath: string}>} value collection of matchPaths\n */\nexport const setMatchPaths = value => {\n  matchPaths = value\n}\n\n/**\n * Return a matchpath url\n * if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n * `/foo?bar=far` => `/page1`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string|null}\n */\nexport const findMatchPath = rawPathname => {\n  const trimmedPathname = cleanPath(rawPathname)\n\n  for (const { matchPath, path } of matchPaths) {\n    if (match(matchPath, trimmedPathname)) {\n      return normalizePagePath(path)\n    }\n  }\n\n  return null\n}\n\n// Given a raw URL path, returns the cleaned version of it (trim off\n// `#` and query params), or if it matches an entry in\n// `match-paths.json`, its matched path is returned\n//\n// E.g. `/foo?bar=far` => `/foo`\n//\n// Or if `match-paths.json` contains `{ \"/foo*\": \"/page1\", ...}`, then\n// `/foo?bar=far` => `/page1`\nexport const findPath = rawPathname => {\n  const trimmedPathname = trimPathname(rawPathname)\n\n  if (pathCache.has(trimmedPathname)) {\n    return pathCache.get(trimmedPathname)\n  }\n\n  let foundPath = findMatchPath(trimmedPathname)\n\n  if (!foundPath) {\n    foundPath = cleanPath(rawPathname)\n  }\n\n  pathCache.set(trimmedPathname, foundPath)\n\n  return foundPath\n}\n\n/**\n * Clean a url and converts /index.html => /\n * E.g. `/foo?bar=far` => `/foo`\n *\n * @param {string} rawPathname A raw pathname\n * @return {string}\n */\nexport const cleanPath = rawPathname => {\n  const trimmedPathname = trimPathname(rawPathname)\n\n  let foundPath = trimmedPathname\n  if (foundPath === `/index.html`) {\n    foundPath = `/`\n  }\n\n  foundPath = normalizePagePath(foundPath)\n\n  return foundPath\n}\n","import prefetchHelper from \"./prefetch\"\nimport emitter from \"./emitter\"\nimport { setMatchPaths, findPath, findMatchPath } from \"./find-path\"\n\nconst preferDefault = m => (m && m.default) || m\n\nconst stripSurroundingSlashes = s => {\n  s = s[0] === `/` ? s.slice(1) : s\n  s = s.endsWith(`/`) ? s.slice(0, -1) : s\n  return s\n}\n\nconst createPageDataUrl = path => {\n  const fixedPath = path === `/` ? `index` : stripSurroundingSlashes(path)\n  return `${__PATH_PREFIX__}/page-data/${fixedPath}/page-data.json`\n}\n\nconst doFetch = (url, method = `GET`) =>\n  new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n    req.open(method, url, true)\n    req.onreadystatechange = () => {\n      if (req.readyState == 4) {\n        resolve(req)\n      }\n    }\n    req.send(null)\n  })\n\nconst loadPageDataJson = loadObj => {\n  const { pagePath, retries = 0 } = loadObj\n  const url = createPageDataUrl(pagePath)\n  return doFetch(url).then(req => {\n    const { status, responseText } = req\n\n    // Handle 200\n    if (status === 200) {\n      try {\n        const jsonPayload = JSON.parse(responseText)\n        if (jsonPayload.path === undefined) {\n          throw new Error(`not a valid pageData response`)\n        }\n\n        return Object.assign(loadObj, {\n          status: `success`,\n          payload: jsonPayload,\n        })\n      } catch (err) {\n        // continue regardless of error\n      }\n    }\n\n    // Handle 404\n    if (status === 404 || status === 200) {\n      // If the request was for a 404 page and it doesn't exist, we're done\n      if (pagePath === `/404.html`) {\n        return Object.assign(loadObj, {\n          status: `failure`,\n        })\n      }\n\n      // Need some code here to cache the 404 request. In case\n      // multiple loadPageDataJsons result in 404s\n      return loadPageDataJson(\n        Object.assign(loadObj, { pagePath: `/404.html`, notFound: true })\n      )\n    }\n\n    // handle 500 response (Unrecoverable)\n    if (status === 500) {\n      return Object.assign(loadObj, {\n        status: `error`,\n      })\n    }\n\n    // Handle everything else, including status === 0, and 503s. Should retry\n    if (retries < 3) {\n      return loadPageDataJson(Object.assign(loadObj, { retries: retries + 1 }))\n    }\n\n    // Retried 3 times already, result is a failure.\n    return Object.assign(loadObj, {\n      status: `error`,\n    })\n  })\n}\n\nconst doesConnectionSupportPrefetch = () => {\n  if (\n    `connection` in navigator &&\n    typeof navigator.connection !== `undefined`\n  ) {\n    if ((navigator.connection.effectiveType || ``).includes(`2g`)) {\n      return false\n    }\n    if (navigator.connection.saveData) {\n      return false\n    }\n  }\n  return true\n}\n\nconst toPageResources = (pageData, component = null) => {\n  const page = {\n    componentChunkName: pageData.componentChunkName,\n    path: pageData.path,\n    webpackCompilationHash: pageData.webpackCompilationHash,\n    matchPath: pageData.matchPath,\n  }\n\n  return {\n    component,\n    json: pageData.result,\n    page,\n  }\n}\n\nexport class BaseLoader {\n  constructor(loadComponent, matchPaths) {\n    // Map of pagePath -> Page. Where Page is an object with: {\n    //   status: `success` || `error`,\n    //   payload: PageResources, // undefined if `error`\n    // }\n    // PageResources is {\n    //   component,\n    //   json: pageData.result,\n    //   page: {\n    //     componentChunkName,\n    //     path,\n    //     webpackCompilationHash,\n    //   }\n    // }\n    this.pageDb = new Map()\n    this.inFlightDb = new Map()\n    this.pageDataDb = new Map()\n    this.prefetchTriggered = new Set()\n    this.prefetchCompleted = new Set()\n    this.loadComponent = loadComponent\n    setMatchPaths(matchPaths)\n  }\n\n  setApiRunner(apiRunner) {\n    this.apiRunner = apiRunner\n    this.prefetchDisabled = apiRunner(`disableCorePrefetching`).some(a => a)\n  }\n\n  loadPageDataJson(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDataDb.has(pagePath)) {\n      return Promise.resolve(this.pageDataDb.get(pagePath))\n    }\n\n    return loadPageDataJson({ pagePath }).then(pageData => {\n      this.pageDataDb.set(pagePath, pageData)\n\n      return pageData\n    })\n  }\n\n  findMatchPath(rawPath) {\n    return findMatchPath(rawPath)\n  }\n\n  // TODO check all uses of this and whether they use undefined for page resources not exist\n  loadPage(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      const page = this.pageDb.get(pagePath)\n      return Promise.resolve(page.payload)\n    }\n    if (this.inFlightDb.has(pagePath)) {\n      return this.inFlightDb.get(pagePath)\n    }\n\n    const inFlight = Promise.all([\n      this.loadAppData(),\n      this.loadPageDataJson(pagePath),\n    ])\n      .then(allData => {\n        const result = allData[1]\n        if (result.status === `error`) {\n          return {\n            status: `error`,\n          }\n        }\n        if (result.status === `failure`) {\n          // throw an error so error trackers can pick this up\n          throw new Error(\n            `404 page could not be found. Checkout https://www.gatsbyjs.org/docs/add-404-page/`\n          )\n        }\n\n        let pageData = result.payload\n        const { componentChunkName } = pageData\n        return this.loadComponent(componentChunkName).then(component => {\n          const finalResult = { createdAt: new Date() }\n          let pageResources\n          if (!component) {\n            finalResult.status = `error`\n          } else {\n            finalResult.status = `success`\n            if (result.notFound === true) {\n              finalResult.notFound = true\n            }\n            pageData = Object.assign(pageData, {\n              webpackCompilationHash: allData[0]\n                ? allData[0].webpackCompilationHash\n                : ``,\n            })\n            pageResources = toPageResources(pageData, component)\n            finalResult.payload = pageResources\n            emitter.emit(`onPostLoadPageResources`, {\n              page: pageResources,\n              pageResources,\n            })\n          }\n          this.pageDb.set(pagePath, finalResult)\n          // undefined if final result is an error\n          return pageResources\n        })\n      })\n      // prefer duplication with then + catch over .finally to prevent problems in ie11 + firefox\n      .then(response => {\n        this.inFlightDb.delete(pagePath)\n        return response\n      })\n      .catch(err => {\n        this.inFlightDb.delete(pagePath)\n        throw err\n      })\n\n    this.inFlightDb.set(pagePath, inFlight)\n    return inFlight\n  }\n\n  // returns undefined if loading page ran into errors\n  loadPageSync(rawPath) {\n    const pagePath = findPath(rawPath)\n    if (this.pageDb.has(pagePath)) {\n      return this.pageDb.get(pagePath).payload\n    }\n    return undefined\n  }\n\n  shouldPrefetch(pagePath) {\n    // Skip prefetching if we know user is on slow or constrained connection\n    if (!doesConnectionSupportPrefetch()) {\n      return false\n    }\n\n    // Check if the page exists.\n    if (this.pageDb.has(pagePath)) {\n      return false\n    }\n\n    return true\n  }\n\n  prefetch(pagePath) {\n    if (!this.shouldPrefetch(pagePath)) {\n      return false\n    }\n\n    // Tell plugins with custom prefetching logic that they should start\n    // prefetching this path.\n    if (!this.prefetchTriggered.has(pagePath)) {\n      this.apiRunner(`onPrefetchPathname`, { pathname: pagePath })\n      this.prefetchTriggered.add(pagePath)\n    }\n\n    // If a plugin has disabled core prefetching, stop now.\n    if (this.prefetchDisabled) {\n      return false\n    }\n\n    const realPath = findPath(pagePath)\n    // Todo make doPrefetch logic cacheable\n    // eslint-disable-next-line consistent-return\n    this.doPrefetch(realPath).then(() => {\n      if (!this.prefetchCompleted.has(pagePath)) {\n        this.apiRunner(`onPostPrefetchPathname`, { pathname: pagePath })\n        this.prefetchCompleted.add(pagePath)\n      }\n    })\n\n    return true\n  }\n\n  doPrefetch(pagePath) {\n    throw new Error(`doPrefetch not implemented`)\n  }\n\n  hovering(rawPath) {\n    this.loadPage(rawPath)\n  }\n\n  getResourceURLsForPathname(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDataDb.get(pagePath)\n    if (page) {\n      const pageResources = toPageResources(page.payload)\n\n      return [\n        ...createComponentUrls(pageResources.page.componentChunkName),\n        createPageDataUrl(pagePath),\n      ]\n    } else {\n      return null\n    }\n  }\n\n  isPageNotFound(rawPath) {\n    const pagePath = findPath(rawPath)\n    const page = this.pageDb.get(pagePath)\n    return page && page.notFound === true\n  }\n\n  loadAppData(retries = 0) {\n    return doFetch(`${__PATH_PREFIX__}/page-data/app-data.json`).then(req => {\n      const { status, responseText } = req\n\n      let appData\n\n      if (status !== 200 && retries < 3) {\n        // Retry 3 times incase of failures\n        return this.loadAppData(retries + 1)\n      }\n\n      // Handle 200\n      if (status === 200) {\n        try {\n          const jsonPayload = JSON.parse(responseText)\n          if (jsonPayload.webpackCompilationHash === undefined) {\n            throw new Error(`not a valid app-data response`)\n          }\n\n          appData = jsonPayload\n        } catch (err) {\n          // continue regardless of error\n        }\n      }\n\n      return appData\n    })\n  }\n}\n\nconst createComponentUrls = componentChunkName =>\n  window.___chunkMapping[componentChunkName].map(\n    chunk => __PATH_PREFIX__ + chunk\n  )\n\nexport class ProdLoader extends BaseLoader {\n  constructor(asyncRequires, matchPaths) {\n    const loadComponent = chunkName =>\n      asyncRequires.components[chunkName]().then(preferDefault)\n\n    super(loadComponent, matchPaths)\n  }\n\n  doPrefetch(pagePath) {\n    const pageDataUrl = createPageDataUrl(pagePath)\n    return prefetchHelper(pageDataUrl, {\n      crossOrigin: `anonymous`,\n      as: `fetch`,\n    })\n      .then(() =>\n        // This was just prefetched, so will return a response from\n        // the cache instead of making another request to the server\n        this.loadPageDataJson(pagePath)\n      )\n      .then(result => {\n        if (result.status !== `success`) {\n          return Promise.resolve()\n        }\n        const pageData = result.payload\n        const chunkName = pageData.componentChunkName\n        const componentUrls = createComponentUrls(chunkName)\n        return Promise.all(componentUrls.map(prefetchHelper)).then(\n          () => pageData\n        )\n      })\n  }\n}\n\nlet instance\n\nexport const setLoader = _loader => {\n  instance = _loader\n}\n\nexport const publicLoader = {\n  // Deprecated methods. As far as we're aware, these are only used by\n  // core gatsby and the offline plugin, however there's a very small\n  // chance they're called by others.\n  getResourcesForPathname: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathname is deprecated. Use loadPage instead`\n    )\n    return instance.i.loadPage(rawPath)\n  },\n  getResourcesForPathnameSync: rawPath => {\n    console.warn(\n      `Warning: getResourcesForPathnameSync is deprecated. Use loadPageSync instead`\n    )\n    return instance.i.loadPageSync(rawPath)\n  },\n  enqueue: rawPath => instance.prefetch(rawPath),\n\n  // Real methods\n  getResourceURLsForPathname: rawPath =>\n    instance.getResourceURLsForPathname(rawPath),\n  loadPage: rawPath => instance.loadPage(rawPath),\n  loadPageSync: rawPath => instance.loadPageSync(rawPath),\n  prefetch: rawPath => instance.prefetch(rawPath),\n  isPageNotFound: rawPath => instance.isPageNotFound(rawPath),\n  hovering: rawPath => instance.hovering(rawPath),\n  loadAppData: () => instance.loadAppData(),\n}\n\nexport default publicLoader\n","const preferDefault = m => (m && m.default) || m\n\nif (process.env.BUILD_STAGE === `develop`) {\n  module.exports = preferDefault(require(`./public-page-renderer-dev`))\n} else if (process.env.BUILD_STAGE === `build-javascript`) {\n  module.exports = preferDefault(require(`./public-page-renderer-prod`))\n} else {\n  module.exports = () => null\n}\n","import React from \"react\"\n\nexport default React.createContext\n","// prefer default export if available\nconst preferDefault = m => m && m.default || m\n\nexports.components = {\n  \"component---src-pages-about-tsx\": () => import(\"./../src/pages/about.tsx\" /* webpackChunkName: \"component---src-pages-about-tsx\" */),\n  \"component---src-pages-contact-tsx\": () => import(\"./../src/pages/contact.tsx\" /* webpackChunkName: \"component---src-pages-contact-tsx\" */),\n  \"component---src-pages-expertise-tsx\": () => import(\"./../src/pages/expertise.tsx\" /* webpackChunkName: \"component---src-pages-expertise-tsx\" */),\n  \"component---src-pages-index-tsx\": () => import(\"./../src/pages/index.tsx\" /* webpackChunkName: \"component---src-pages-index-tsx\" */),\n  \"component---src-pages-pricing-tsx\": () => import(\"./../src/pages/pricing.tsx\" /* webpackChunkName: \"component---src-pages-pricing-tsx\" */)\n}\n\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\n\nimport InternalPageRenderer from \"./page-renderer\"\n\nconst ProdPageRenderer = ({ location, pageResources }) => {\n  if (!pageResources) {\n    return null\n  }\n  return React.createElement(InternalPageRenderer, {\n    location,\n    pageResources,\n    ...pageResources.json,\n  })\n}\n\nProdPageRenderer.propTypes = {\n  location: PropTypes.shape({\n    pathname: PropTypes.string.isRequired,\n  }).isRequired,\n}\n\nexport default ProdPageRenderer\n","import { Theme } from '@theme/styled';\n\nconst theme: Theme = {\n  color: {\n    primary: '#f00',\n    // secondary: '#008489',\n    // secondary: 'rgb(237,31,36)',\n    // tertiary: '#f39b84',\n    secondary: 'rgb(237,31,36)',\n    // tertiary: '#75706b',\n    tertiary: '#fff',\n    gray: {\n      lightest: '#faf8f5',\n      light: '#e2dedc',\n      medium: '#aaa5a3',\n      dark: '#75706b',\n      darkest: '#463b36',\n    },\n    status: {\n      error: {\n        light: '#ffeeea',\n        medium: '#ed6c4a',\n        dark: '#ba3816',\n      },\n    },\n    text: {\n      heading: '#463b36',\n      body: '#75706b',\n    },\n    disabled: '#aaa5a3',\n  },\n  spacing: {\n    unit: 8,\n  },\n  shape: {\n    borderRadius: {\n      small: 0,\n      medium: 0,\n      large:  0,\n    },\n  },\n};\n\nexport default theme;\n","const plugins = require(`./api-runner-browser-plugins`)\nconst {\n  getResourcesForPathname,\n  getResourcesForPathnameSync,\n  getResourceURLsForPathname,\n  loadPage,\n  loadPageSync,\n} = require(`./loader`).publicLoader\n\nexports.apiRunner = (api, args = {}, defaultReturn, argTransform) => {\n  // Hooks for gatsby-cypress's API handler\n  if (process.env.CYPRESS_SUPPORT) {\n    if (window.___apiHandler) {\n      window.___apiHandler(api)\n    } else if (window.___resolvedAPIs) {\n      window.___resolvedAPIs.push(api)\n    } else {\n      window.___resolvedAPIs = [api]\n    }\n  }\n\n  let results = plugins.map(plugin => {\n    if (!plugin.plugin[api]) {\n      return undefined\n    }\n\n    // Deprecated April 2019. Use `loadPageSync` instead\n    args.getResourcesForPathnameSync = getResourcesForPathnameSync\n    // Deprecated April 2019. Use `loadPage` instead\n    args.getResourcesForPathname = getResourcesForPathname\n    args.getResourceURLsForPathname = getResourceURLsForPathname\n    args.loadPage = loadPage\n    args.loadPageSync = loadPageSync\n\n    const result = plugin.plugin[api](args, plugin.options)\n    if (result && argTransform) {\n      args = argTransform({ args, result, plugin })\n    }\n    return result\n  })\n\n  // Filter out undefined results.\n  results = results.filter(result => typeof result !== `undefined`)\n\n  if (results.length > 0) {\n    return results\n  } else if (defaultReturn) {\n    return [defaultReturn]\n  } else {\n    return []\n  }\n}\n\nexports.apiRunnerAsync = (api, args, defaultReturn) =>\n  plugins.reduce(\n    (previous, next) =>\n      next.plugin[api]\n        ? previous.then(() => next.plugin[api](args, next.options))\n        : previous,\n    Promise.resolve()\n  )\n"],"sourceRoot":""}